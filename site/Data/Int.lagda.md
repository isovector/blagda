```agda
open import 1Lab.HLevel.Retracts
open import 1Lab.HLevel.Sets
open import 1Lab.Univalence
open import 1Lab.Type.Dec
open import 1Lab.HLevel
open import 1Lab.Equiv
open import 1Lab.Path
open import 1Lab.Type

open import Data.Nat

module Data.Int where
```

# Integers

The **integers** are what you get when you complete the [additive monoid
structure on the naturals] into a [group]. In non-cubical Agda, a
representation of the integers as a coproduct $\mathbb{N} \coprod
\mathbb{N}$ with one of the factors offset (to avoid having two zeroes)
is adopted. In Cubical Agda we can adopt a representation much closer to
a "classical" construction of the integers:

[additive monoid structure on the naturals]: Algebra.Monoid.html#ℕ-+
[group]: Algebra.Group.html

```agda
data Int : Type where
  diff : (x y : Nat) → Int
  quot : (m n : Nat) → diff m n ≡ diff (suc m) (suc n)
```

This is an alternative representation of the construction of integers as
pairs $(x , y)\colon \mathbb{N}^2$ where $(a,b) = (c, d)$ iff $a + d = b
+ c$: An integer is an equivalence class of pairs of naturals, where
$(a, b)$ is identified with $(1 + a, 1 + b)$, or, more
type-theoretically, the integers are generated by the constructor
`diff`{.Agda} which embeds a pair of naturals, and the path constructor
`quot`{.Agda} which expresses that $(a, b)$ = $(1 + a, 1 + b)$.

As an example of using this generating path, we can prove that any pair
$(a, a)$ has a path from the "canonical zero", $(0, 0)$:

```agda
zeroes : (n : Nat) → diff 0 0 ≡ diff n n
zeroes zero = refl
zeroes (suc n) = zeroes n ∙ quot _ _
```

Furthermore, offsetting both components by the same natural does nothing:

```agda
cancel : (a b n : Nat) → diff a b ≡ diff (n + a) (n + b)
cancel a b zero = refl
cancel a b (suc n) = cancel a b n ∙ quot _ _
```

All equivalence classes have a representative of the form $(0,b)$ or
$(b,0)$:

```agda
offset-negative : (a b : Nat) → diff a (a + b) ≡ diff 0 b
offset-negative zero b = refl
offset-negative (suc a) b =
  diff (suc a) (suc (a + b)) ≡⟨ sym (quot _ _) ⟩
  diff a (a + b)             ≡⟨ offset-negative a b ⟩
  diff 0 b                   ∎

offset-positive : (a b : Nat) → diff (a + b) a ≡ diff b 0
offset-positive zero b = refl
offset-positive (suc a) b =
  diff (suc (a + b)) (suc a) ≡⟨ sym (quot _ _) ⟩
  diff (a + b) a             ≡⟨ offset-positive a b ⟩
  diff b 0                   ∎
```

And finally, we can _prove_ that this definition satisfies the more
common equality used in the construction of integers as a quotient set:
$(a, b) = (c, d)$ if $(a + d) = (b + c)$.

```agda
same-difference : {a b c d : Nat} → a + d ≡ b + c → diff a b ≡ diff c d
same-difference {zero} {b} {c} {d} path =
  sym ( diff c d       ≡⟨ ap₂ diff refl path ⟩
        diff c (b + c) ≡⟨ ap₂ diff refl (+-commutative b c) ⟩
        diff c (c + b) ≡⟨ offset-negative _ _ ⟩
        diff 0 b       ∎ 
      )
same-difference {suc a} {zero} {c} {d} path =
  sym ( diff c d             ≡⟨ ap₂ diff (sym path) refl ⟩
        diff (suc a + d) d   ≡⟨ ap₂ diff (+-commutative (suc a) d) refl ⟩
        diff (d + suc a) d   ≡⟨ offset-positive _ _ ⟩
        diff (suc a) 0       ∎
      )
same-difference {suc a} {suc b} {c} {d} path =
  diff (suc a) (suc b) ≡⟨ sym (quot _ _) ⟩
  diff a b             ≡⟨ same-difference (suc-inj path) ⟩
  diff c d             ∎
```

Furthermore, using a cubical argument, we can prove that the
`quot`{.Agda} constructor satisfies the following two equalities,
which are necessary when relating `Int`{.Agda} to a more concrete
definition which can be shown to have decidable equality:

```agda
quot-diamond : (a b : Nat)
             → Square (quot a b) (quot a b)
                      (quot (suc a) (suc b))
                      (quot (suc a) (suc b))
quot-diamond a b i j =
  hcomp (λ k → λ { (i = i0) → quot a b j
                 ; (i = i1) → quot (suc a) (suc b) (j ∧ k)
                 ; (j = i0) → quot a b i
                 ; (j = i1) → quot (suc a) (suc b) (i ∧ k)
                 })
        (quot a b (i ∨ j))

quot-triangle : (a b : Nat) (i : I) → diff a b ≡ quot a b i
quot-triangle a b i j = hcomp (λ k → λ
  { (i = i0) → diff a b
  ; (j = i0) → diff a b
  ; (j = i1) → quot a b (i ∧ k)
  }) (diff a b)
```

As a finishing touch, we give `Int` instances for `Number`{.Agda} and
`Negative`{.Agda}, meaning that we can use positive and negative
literals with integer type:

```agda
instance
  Number-Int : Number Int
  Number-Int .Number.Constraint _ = ⊤
  Number-Int .Number.fromNat n = diff n 0

  Negative-Int : Negative Int
  Negative-Int .Negative.Constraint _ = ⊤
  Negative-Int .Negative.fromNeg n = diff 0 n
```

## Discreteness

To prove that `Int`{.Agda} is [discrete] (and thus [a set]), we prove
that it is equivalent to an inductive (rather than higher-inductive)
definition of the integers. Since this definition (which we call
`Int'`{.Agda}) has decidable equality, it is a set.

[discrete]: agda://1Lab.Type.Dec#Discrete
[a set]: agda://1Lab.HLevel#isSet

```agda
module _ where
  open import Data.Int.Inductive
    renaming ( Int to Int'
             ; Discrete-Int to Discrete-Int'
             )
```

There is a canonical map which takes pairs of naturals to their
difference as an `Int'`{.Agda}, which is `ℕ-`{.Agda}; It can be shown
that this map extends to a function from `Int`{.Agda}, since it respects
the generating equation `quot`{.Agda} definitionally:

```agda
  private
    toInt' : Int → Int'
    toInt' (diff x y) = x ℕ- y
    toInt' (quot m n i) = m ℕ- n

    fromInt' : Int' → Int
    fromInt' (pos x) = diff x 0
    fromInt' (negsuc x) = diff 0 (suc x)
```

Mapping from `Int'`{.Agda} to `Int`{.Agda} sends the positive numbers to
$(x, 0)$ and the negative numbers to $(0, x)$.

```agda
    toFromInt' : (x : Int) → fromInt' (toInt' x) ≡ x
    toFromInt' (diff x zero)            = refl
    toFromInt' (diff zero (suc y))      = refl
    toFromInt' (diff (suc x) (suc y))   = toFromInt' (diff x y) ∙ quot _ _

    toFromInt' (quot m zero i)          = quot-triangle _ _ i
    toFromInt' (quot zero (suc n) i)    = quot-triangle _ _ i
    toFromInt' (quot (suc m) (suc n) i) =
      toFromInt' (quot _ _ i) ∙ quot-diamond _ _ i

    fromToInt' : (x : Int') → toInt' (fromInt' x) ≡ x
    fromToInt' (pos x) = refl
    fromToInt' (negsuc x) = refl

    Int'≡Int : Int' ≡ Int
    Int'≡Int = Iso→path (fromInt' , iso toInt' toFromInt' fromToInt')
```

With a quick appeal to `univalence`{.Agda ident=Iso→path}, we get that
our desired type of integers is a set:

```agda
  Discrete-Int : Discrete Int
  Discrete-Int = subst Discrete Int'≡Int Discrete-Int'

  isSet-Int : isSet Int
  isSet-Int = Discrete→isSet Discrete-Int
```

# Recursion

If we want to define a map $f : \mathbb{Z} \to X$, it suffices to give a
function $f : \mathbb{N}^2 \to X$ which respects the quotient, in the
following sense:

```agda
Int-rec : ∀ {ℓ} {X : Type ℓ}
        → (f : Nat → Nat → X)
        → (q : (a b : _) → f a b ≡ f (suc a) (suc b))
        → Int → X
Int-rec f q (diff x y) = f x y
Int-rec f q (quot m n i) = q m n i
```

However, since $X$ can be a more general space, not necessarily a _set_,
defining a _binary_ operation $f' : \mathbb{Z}^2 \to X$ can be quite
involved! It doesn't suffice to exhibit a function from $\mathbb{N}^4$
which respects the quotient separately in each argument:

```agda
Int-rec₂ : ∀ {ℓ} {B : Type ℓ}
         → (f : Nat × Nat → Nat × Nat → B)
         → (pl     : (a b x y : _) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
         → (pr     : (a b x y : _) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y))
```

In addition, we must have that these two _paths_ `pl` and `pr` are
_coherent_. There are two ways of obtaining an equality $f(a, b, x, y) =
f(\mathrm{S}a,\mathrm{S}b,\mathrm{S}x,\mathrm{S}y)$ (`pl` after `pr` and
`pr` after `pl`, respectively) and these _must_ be homotopic:

```agda
         → (square : (a b x y : _) →
              Square (pl a b x y) (pr a b x y)
                     (pr (suc a) (suc b) x y)
                     (pl a b (suc x) (suc y)))
         → Int → Int → B
```

The type of `square` says that we need the following square of paths to
commute, which says exactly that `pl ∙ pr` and `pr ∙ pl` are homotopic
and imposes no further structure on $X$[^1]:

[^1]: In the diagram, we write $\mathrm{S}x$ for `suc x`.

~~~{.quiver .tall-1}
\[\begin{tikzcd}
  {f(a,b,x,y)} && {f(a,b,\mathrm{S}x,\mathrm{S}y)} \\
  \\
  {f(\mathrm{S}a,\mathrm{S}b, x, y)} && {f(\mathrm{S}a,\mathrm{S}b,\mathrm{S}x,\mathrm{S}y)}
  \arrow["{pl(a,b,x,y)}", from=1-1, to=3-1]
  \arrow["{pr(a,b,x,y)}", from=1-1, to=1-3]
  \arrow["{pl(a,b,\mathrm{S}x,\mathrm{S}y)}"', from=1-3, to=3-3]
  \arrow["{pr(\mathrm{S}a,\mathrm{S}b,x,y)}"', from=3-1, to=3-3]
\end{tikzcd}\]
~~~

```agda
Int-rec₂ f p-l p-r sq (diff a b) (diff x y)     = f (a , b) (x , y)
Int-rec₂ f p-l p-r sq (diff a b) (quot x y i)   = p-r a b x y i
Int-rec₂ f p-l p-r sq (quot a b i) (diff x y)   = p-l a b x y i
Int-rec₂ f p-l p-r sq (quot a b i) (quot x y j) = sq a b x y i j
```

However, when the type $X$ we are mapping into `is a set`{.Agda
ident=isSet}, as is the case for the integers themselves, the square is
automatically satisfied, so we can give a simplified recursion
principle:

```agda
Int-rec₂-set :
  ∀ {ℓ} {B : Type ℓ}
  → isSet B
  → (f : Nat × Nat → Nat × Nat → B)
  → (pl     : (a b x y : _) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
  → (pr     : (a b x y : _) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y))
  → Int → Int → B
Int-rec₂-set iss-b f pl pr = Int-rec₂ f pl pr square where
  square : (a b x y : _) → _
  square a b x y =
    transport (λ i → PathP≡Path (λ i → pl a b x y i ≡ pl a b (suc x) (suc y) i)
                                (pr a b x y) (pr (suc a) (suc b) x y)
                                (~ i))
              (iss-b _ _ _ _)
```

Furthermore, when proving _`propositions`{.Agda ident=isProp}_ of the
integers, the quotient is automatically respected, so it suffices to
give the case for `diff`{.Agda}:

```agda
Int-elim-prop : ∀ {ℓ} {P : Int → Type ℓ}
              → ((x : Int) → isProp (P x))
              → (f : (a b : Nat) → P (diff a b))
              → (x : Int) → P x
Int-elim-prop pprop f (diff a b) = f a b
Int-elim-prop pprop f (quot m n i) =
  isProp→PathP (λ i → pprop (quot m n i)) (f m n) (f (suc m) (suc n)) i
```

<details>
<summary>There are also variants for binary and ternary predicates.</summary>
```agda
Int-elim₂-prop : ∀ {ℓ} {P : Int → Int → Type ℓ}
               → ((x y : Int) → isProp (P x y))
               → (f : (a b x y : Nat) → P (diff a b) (diff x y))
               → (x : Int) (y : Int) → P x y
Int-elim₂-prop pprop f =
  Int-elim-prop (λ x → isHLevelΠ 1 (pprop x))
    λ a b int → Int-elim-prop (λ x → pprop (diff a b) x) (f a b) int

Int-elim₃-prop : ∀ {ℓ} {P : Int → Int → Int → Type ℓ}
               → ((x y z : Int) → isProp (P x y z))
               → (f : (a b c d e f : Nat) → P (diff a b) (diff c d) (diff e f))
               → (x : Int) (y : Int) (z : Int) → P x y z
Int-elim₃-prop pprop f =
  Int-elim₂-prop (λ x y → isHLevelΠ 1 (pprop x y))
    λ a b c d int → Int-elim-prop (λ x → pprop (diff a b) (diff c d) x)
                                  (f a b c d)
                                  int
```
</details>

# Algebra

With these recursion and elimination helpers, it becomes routine to lift
the algebraic operations from naturals to integers:

## Successors

The simplest "algebraic operation" on an integer is taking its
successor. In fact, the integers are characterised by being the free
type with an equivalence - that equivalence being "successor".

```agda
sucℤ : Int → Int
sucℤ (diff x y) = diff (suc x) y
sucℤ (quot m n i) = quot (suc m) n i

predℤ : Int → Int
predℤ (diff x y) = diff x (suc y)
predℤ (quot m n i) = quot m (suc n) i
```

The successor of $(a, b)$ is $(1 + a, b)$. Similarly, the predecessor of
$(a, b)$ is $(a, 1 + b)$. By the generating equality `quot`{.Agda}, we
have that predecessor and successor are inverses, since applying both
(in either order) takes $(a, b)$ to $(1 + a, 1 + b)$.

```agda
predSucℤ : (x : Int) → predℤ (sucℤ x) ≡ x
predSucℤ (diff x y) = sym (quot x y)
predSucℤ (quot m n i) j = quot-diamond m n i (~ j)

sucPredℤ : (x : Int) → sucℤ (predℤ x) ≡ x
sucPredℤ (diff x y) = sym (quot x y)
sucPredℤ (quot m n i) j = quot-diamond m n i (~ j)

isEquiv-sucℤ : isEquiv sucℤ
isEquiv-sucℤ = isIso→isEquiv (iso predℤ sucPredℤ predSucℤ)

isEquiv-predℤ : isEquiv predℤ
isEquiv-predℤ = isIso→isEquiv (iso sucℤ predSucℤ sucPredℤ)
```

## Addition

```agda
_+ℤ_ : Int → Int → Int
_+ℤ_ =
  Int-rec₂-set
    isSet-Int
    (λ { (a , b) (c , d) → diff (a + c) (b + d)})
    (λ a b x y → quot _ _)
    (λ a b x y → quot _ _ ∙ ap₂ diff (sym (+-sucʳ _ _)) (sym (+-sucʳ _ _)))
```

Since addition of integers is (essentially!) addition of pairs of
naturals, the algebraic properties of `+`{.Agda} on the natural numbers
automatically lift to properties about `_+ℤ_`{.Agda}, using the
recursion helpers for props (`Int-elim-prop`{.Agda}) and the fact that
`equality of integers is a proposition`{.Agda ident=isSet-Int}.

```agda
+ℤ-associative : (x y z : Int) → (x +ℤ y) +ℤ z ≡ x +ℤ (y +ℤ z)
+ℤ-associative =
  Int-elim₃-prop
    (λ x y z → isSet-Int _ _)
    (λ a b c d e f → ap₂ diff (+-associative a c e) (+-associative b d f))

+ℤ-zeroˡ : (x : Int) → 0 +ℤ x ≡ x
+ℤ-zeroˡ = Int-elim-prop (λ x → isSet-Int _ _) (λ a b → refl)

+ℤ-zeroʳ : (x : Int) → x +ℤ 0 ≡ x
+ℤ-zeroʳ =
  Int-elim-prop (λ x → isSet-Int _ _) (λ a b → ap₂ diff (+-zeroʳ a) (+-zeroʳ b))

+ℤ-commutative : (x y : Int) → x +ℤ y ≡ y +ℤ x
+ℤ-commutative =
  Int-elim₂-prop (λ x y → isSet-Int _ _)
    (λ a b c d → ap₂ diff (+-commutative a c) (+-commutative b d))
```

## Inverses

Every integer $x$ has an additive inverse, denoted $-x$, which is
obtained by swapping the components of the pair. Since the definition of
`negate`{.Agda} is very simple, it can be written conveniently without
using `Int-rec`{.Agda}:

```agda
negate : Int → Int
negate (diff x y) = diff y x
negate (quot m n i) = quot n m i
```

The proof that $-x$ is an additive inverse to $x$ follows, essentially,
from commutativity of addition on natural numbers, and the fact that
`all zeroes are identified`{.Agda ident=zeroes}.

```agda
+ℤ-inverseʳ : (x : Int) → x +ℤ negate x ≡ 0
+ℤ-inverseʳ =
  Int-elim-prop (λ _ → isSet-Int _ _) λ where
    a b → diff (a + b) (b + a) ≡⟨ ap₂ diff refl (+-commutative b a) ⟩
          diff (a + b) (a + b) ≡⟨ sym (zeroes (a + b)) ⟩
          diff 0 0             ∎
          
+ℤ-inverseˡ : (x : Int) → negate x +ℤ x ≡ 0
+ℤ-inverseˡ =
  Int-elim-prop (λ _ → isSet-Int _ _) λ where
    a b → diff (b + a) (a + b) ≡⟨ ap₂ diff (+-commutative b a) refl ⟩
          diff (a + b) (a + b) ≡⟨ sym (zeroes (a + b)) ⟩
          diff 0 0             ∎
```

Since `negate`{.Agda} is precisely what's missing for `Nat`{.Agda} to be
a group, we _can_ turn [the integers] into a group. Subtraction is
defined as addition with the inverse, rather than directly on `diff`{.Agda}:

[the integers]: Algebra.Group.html#the-integers

```agda
_-ℤ_ : Int → Int → Int
x -ℤ y = x +ℤ negate y
```
