```agda
open import 1Lab.Prelude

open import Algebra.Magma

module Algebra.Semigroup where
```

<!--
```agda
private variable
  ℓ ℓ₁ : Level
  A : Type ℓ
```
-->



# Semigroups

```agda
record isSemigroup {A : Type ℓ} (_⋆_ : A → A → A) : Type ℓ where
```

A **semigroup** is an associative `magma`{.Agda ident=isMagma}, that is, a set
equipped with a choice of _associative_ binary operation `⋆`.

```agda
  field
    hasIsMagma : isMagma _⋆_
    associative : {x y z : A} → x ⋆ (y ⋆ z) ≡ (x ⋆ y) ⋆ z

  open isMagma hasIsMagma public

open isSemigroup public
```

To see why the set truncation is really necessary, it helps to
explicitly describe the expected structure of a "∞-semigroup" in terms
of the language of higher categories:

- An ∞-groupoid `A`, equipped with

- A map `_⋆_ : A → A → A`, such that

- `⋆` is _associative_: there exists an invertible 2-morphism `α : A ⋆
(B ⋆ C) ≡ (A ⋆ B) ⋆ C` (called the associator), satisfying

- The _pentagon identity_, i.e. there is a path `π` (called, no joke,
the "pentagonator") witnessing commutativity of the diagram below, where
all the faces are `α`:

~~~{.quiver .tall-2}
\[\begin{tikzcd}
  & {(a \star b) \star (c\star d)} \\
  {((a \star b) \star c)\star d} && {a\star(b\star(c\star d)))} \\
  \\
  {(a\star(b\star c))\star d} && {a\star((b\star c)\star d)}
  \arrow[Rightarrow, no head, from=2-1, to=1-2]
  \arrow[Rightarrow, no head, from=1-2, to=2-3]
  \arrow[Rightarrow, no head, from=2-3, to=4-3]
  \arrow[Rightarrow, no head, from=4-3, to=4-1]
  \arrow[Rightarrow, no head, from=4-1, to=2-1]
\end{tikzcd}\]
~~~

- The pentagonator satisfies its own coherence law, which looks like the
Stasheff polytope $K_5$, and so on, "all the way up to infinity".

By explicitly asking that `A` be truncated at the level of sets, we have
that the associator automatically satisfies the pentagon identity -
because all parallel paths in a set are equal. Furthermore, by the
upwards closure of h-levels, any further coherence condition you could
dream up and write down for these morphisms is automatically satisfied.

As a consequence of this truncation, we get that being a semigroup
operator is a _property_ of the operator:

```agda
isProp-isSemigroup : {_⋆_ : A → A → A} → isProp (isSemigroup _⋆_)
isProp-isSemigroup x y i .hasIsMagma = isProp-isMagma (x .hasIsMagma) (y .hasIsMagma) i
isProp-isSemigroup {_⋆_ = _⋆_} x y i .associative {a} {b} {c} =
  x .hasIsSet (a ⋆ (b ⋆ c)) ((a ⋆ b) ⋆ c) (x .associative) (y .associative) i
```

A **semigroup structure on** a type packages up the binary operation and
the axiom in a way equivalent to a `structure`{.Agda ident=Structure}.

```agda
SemigroupOn : Type ℓ → Type ℓ
SemigroupOn X = Σ (isSemigroup {A = X})
```

`SemigroupOn`{.Agda} is a univalent structure, because it is equivalent
to a structure expressed as a `structure description`{.Agda
ident=StrDesc}. This is only the case because `isSemigroup`{.Agda} is a
proposition, i.e.  `SemigroupOn`{.Agda} can be expressed as a "structure
part" (the binary operation) and an "axiom part" (the associativity)!

```agda
module _ where
  private
    sg-desc : StrDesc ℓ ℓ (λ X → (X → X → X)) ℓ
    sg-desc .StrDesc.descriptor = s∙ s→ (s∙ s→ s∙)
    sg-desc .StrDesc.axioms X = isSemigroup
    sg-desc .StrDesc.axioms-prop X s = isProp-isSemigroup

  SemigroupStr : Structure ℓ (SemigroupOn {ℓ = ℓ})
  SemigroupStr = Desc→Str sg-desc

  SemigroupStr-univ : isUnivalent (SemigroupStr {ℓ = ℓ})
  SemigroupStr-univ = Desc→isUnivalent sg-desc
```

One can check that the notion of semigroup homomorphism generated by
`SemigroupStr`{.Agda} corresponds exactly to the expected definition,
and does not have any superfluous information:

```agda
module _
  {A : Type} {_⋆_ : A → A → A} {as : isSemigroup _⋆_}
  {B : Type} {_*_ : B → B → B} {bs : isSemigroup _*_}
  {f : A ≃ B}
  where

  _ : SemigroupStr .is-hom (A , _⋆_ , as) (B , _*_ , bs) f
    ≡ ( (x y : A) → f .fst (x ⋆ y) ≡ (f .fst x) * (f .fst y))
  _ = refl
```


## The "min" semigroup

An example of a naturally-occuring semigroup are the natural numbers
under taking `minimums`{.Agda ident=min}.

```agda
open import Data.Nat

Nat-min : isSemigroup min
Nat-min .hasIsMagma .hasIsSet = isSet-Nat
Nat-min .associative = min-assoc _ _ _
```

What is meant by "naturally occuring" is that this semigroup can not be
made into a monoid: There is no natural number `unit` such that, for all
`y`, `min unit y ≡ y` and `min y unit ≡ y`.

```agda
private
  min-no-id : (unit : Nat) → ((y : Nat) → min unit y ≡ y) → ⊥
  min-no-id x id =
    let
      sucx≤x : suc x ≤ x
      sucx≤x = subst (λ e → e ≤ x) (id (suc x)) (min-≤ˡ x (suc x))
    in ¬sucx≤x x sucx≤x
```

